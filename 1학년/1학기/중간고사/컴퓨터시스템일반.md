##### 컴퓨터의 3대 하드웨어
* CPU (연산/제어 장치) - 명령어를 실행하는 장치
* RAM (주기억장치) - 현재 실행 중인 프로그램이 기억되는 장치
* 하드디스크 (보조기억장치) - 모든 데이터와 프로그램을 저장하는 장치

##### 운영체제의 역할
* 프로세스 관리
* 기억장치 관리 (주기억장치, 보조기억장치, 가상기억장치)
* 파일 관리, 디스크 관리
* 기타 자원 관리 (입출력 등)
<br>
를 통해<br><br>
* 처리량(Throughput, 단위 시간 당 처리하는 작업량) 증대
* 응답시간(Turn-around Time, 작업 의뢰부터 응답까지의 시간) 단축
* 신뢰성(Reliability, 실패없이 주어진 기능을 수행하는 능력) 향상
* 사용도(Availability, 일정 시간동안 실제로 사용한 기간/비율) 향상
<br>
하고,<br><br>
* 사람과 기계간의 중재자 역할
* 사람이 편리하게 사용할 수 있는 환경 제공
* GUI(Graphic User Interface)
<br>
등의 역할을 수행한다.<br><br>
=&gt; 운영체제의 역할 : 자원의 효율적 관리 + 사용자의 편의성 제공

##### 운영체제 유형
* 일괄처리시스템 (Batch Processing System)
  * 유사한 작업끼리 묶어서 한 번에 하나씩 순서대로 처리
  * 입출력장치와 CPU의 속도차이 때문에 CPU 유휴상태(idle) 발생 가능<br><br>
* 다중 프로그래밍 시스템 (Multiprogramming System)
  * 여러 개의 프로그램을 동시에 메모리에 적재시켜 놓고 CPU를 나눠 쓰게 함
  * 메모리 관리 필요
  * 어떤 것을 처리 할것인지에 대한 스케쥴링 방법이 필요하다.<br><br>
* 시분할 시스템 (Time Sharing System)
  * 여러 사용자가 동시에 컴퓨터를 사용할 수 앗도록 아주 짧은 시간동안 사용하고, 다른 사용자에 사용권한 넘겨서 여러 사용자가 컴퓨터를 공유
  * 컴퓨터를 혼자 사용하는 것 처럼 느끼게 됨
  * 다중 프로그래밍 환경이 지원되어야 함
  * 입출력장치와 파일 등에 대한 접근 제어가 필요함<br><br>
* 다중 처리 시스템 (Multi Processing System)
  * 병렬 처리 시스템 (Parallel Processing System)와 동치
  * 2개 이상의 프로세서가 동시에 동작함
  * 신뢰도 향상 - 하나의 프로세서가 장애를 일으켜도 다른 프로세서가 작업 계속 수행 가능
  * 신속한 처리
  * 운영체제의 세심한 설계 필요 - 프로세서의 연결 / 상호 제어 등<br><br>
* 실시간 시스템 (Real-Time System)
  * 입력되는 데이터를 짧은 시간, 혹은 특정한 제한 시간 내에 응답 해야 하는 환경에서 사용
  * 입력이 불시에 발생하므로 빠른 입출력장치 필요
  * 각 사건의 중요도에 의한 우선순위에 따라 처리<br><br>
* 분산 처리 시스템 (Distributed Processing System)
  * 메모리 / 프로게서가 독립적으로 운영되고 필요할 때 통신을 함
  * 서로 원격지에 있는 자원(CPU, 기억장치, 프린터 등)을 편리하게 공유하는 방법을 제공함

##### 프로세스
* 프로세스란?
  * 디스크에 있던 프로그램을 실행하기 위해서 주기억장치로 가져온 프로그램
  * 프로그램이 실행하기 위해 CPU 및 다른 자원을 요구하고 할당받아 활동 상태에 있는 것
  * 실행중인 프로그램
  * PCB를 갖는 프로그램
  * 운영체제가 관리하는 살행 주체 단위<br><br>
* PCB란?
  * 프로세스에 대한 각종 정보를 담고 있음
  * 프로그램이 주기억장치로 로딩되면, 운영체제는 PCB 생성함
  * 운영체제가 CPU를 다른 프로세스에 넘길 때, 프로세스에 관한 모든 정보를 PCB에 저장함<br><br>
* PCB 구조
  * 포인터
  * 프로세스의 상태
  * 프로세스 번호(식별자)
  * 프로그램 카운터(PC레지스터)
  * 프로세스 우선순위(스케쥴러)
  * 프로세스 위치의 포인터<br><br>
* 프로세스 상태 전이
  * <b>(fetch)</b>&nbsp;&nbsp;보조기억장치의 프로그램은 실행되기 위해 메모리로 로딩되어 <b>준비(ready)</b> 상태가 됨
  * <b>(dispatch)</b>&nbsp;&nbsp;<b>준비</b> 상태에 있는 프로세스 중에서 한 개가 선택되어(by 스케쥴러) CPU가 명령어를 실행하고 있는 프로세스는 <b>실행(running)</b> 상태가 됨
  * <b>(block)</b>&nbsp;&nbsp;<b>실행</b> 상태의 프로세스가 어떤 사건(ex - I/O)이 일어나거나 어떤 조건이 만족되어야 할 때 <b>대기(waiting)상태</b>가 된다.
  * <b>(wake up)</b>&nbsp;&nbsp;<b>대기</b> 상태에 있던 프로세스가 기다리던 사건이 만족되면 <b>준비</b> 상태로 전이됨
  * <b>(timeout)</b>&nbsp;&nbsp;<b>실행</b> 중인 프로세스가 혼자 CPU를 독점하는 것을 방지하기 위해 강제로 <b>준비</b>상태로 전이시킴
<table>
<tr><th></th> <th>PCB</th> <th>CPU</th> <th>RAM</th></tr>
<tr><th>준비</th> <td>O</td> <td>X</td> <td>O</td></tr>
<tr><th>대기</th> <td>O</td> <td>X</td> <td>O</td></tr>
<tr><th>실행</th> <td>O</td> <td>O</td> <td>O</td></tr>
</table>

##### 스케쥴링
* 스케쥴링 - 컴퓨터 시스템의 모든 자원의 성능을 향상시키기 위해 자원에 대한 사용 순서를 결정하기 위한 정책<br><br>
* 프로세스 스케쥴러(CPU 스케쥴러, 단기 스케쥴러)
  * <b>준비</b>상태에 있는 프로세스 중에서 어느 프로세스에게 CPU를 <b>할당</b>할 지를 결정
  * 속도가 빨라야 함
  * 메모리 -&gt; CPU<br><br>
* 작업 스케쥴러(장기 스케쥴러)
  * <b>하드디스크</b>에 저장되어 있는 어떤 프로그램을 <b>메모리로 적재</b>할 것인지 결정
  * 다중 프로그래밍의 정도를 제어
  * 하드디스크 -&gt; 메모리<br><br>
* 스케쥴링의 기준
  * CPU 이용률(Utilization) - 실제 시스템에서는 40~90% 값을 가진다.
  * 처리량(Throughput) - 단위 시간당 완료된 프로세스의 수
  * 총 처리시간(Turnaround Time) - 대기 + 실행 + 입출력 시간
  * 대기 시간(Waiting time) - 준비완료 큐에서 대기하면서 보낸 시간의 합
  * 응답 시간(Response time) - 하나의 요규를 제출한 후 첫 번째 응답이 나올때 까지의 시간
  * <b>이용률</b>과 <b>처리량</b>을 <b>최대화</b> 하고, <b>총 처리 시간</b>, <b>대기 시간</b>, <b>응답 시간</b>을 <i>최소화</i>하는 것이 바람직함<br><br>
* 선점 / 비선점
  * 선점(preemtive) - CPU를 할당받아 실행 중인 프로세스에게서 <b>강제로</b> CPU를 <b>빼앗아</b> 다른 프로세스에 넘겨주는 방법
  * 비선점(nonpreemtive) - 프로세스가 CPU를 할당받으면 그 프로세스가 끝나거나 반환하지 않는 한 <b>계속 CPU를 사용</b>하는 방법

##### 스케쥴링 기법
* FCFS(First Come First Served) = FIFO(First In First Out)
  * 준비 상태에 도착한 순서에 따라 <b>선착순</b>으로 CPU를 할당하는 <b>비선점</b> 스케쥴링 기법
  * 중요하지 않은 작업이 중요한 작업을 기다리게 할 수 있음
  * 빠른 응답 시간을 요구하는 시스템에 부적절<br><br>
* SJF(Shortest Job First)
  * <b>CPU요구량</b>이 가장 <b>짧은</b> 프로세스에게 먼저 CPU를 할당하는 <b>비선점</b> 스케쥴링 기법
  * 평균 대기시간 최소
  * 준비 상태에 있는 각 프로세스의 CPU 요구 시간을 모두 알아야 하므로 프로세스의 예측을 필요로 하지만 어려움<br><br>
* SRT(Shortest Remaining Time first)
  * <b>남은 실행 시간</b>이 가장 <b>짧은</b> 프로세스에게 CPU를 할당하는 <b>선점</b> 스케쥴링 기법
  * SJF 선점 에디션
  * 선점에 따르 오버헤드
  * 긴 프로세스 기아상태
  * 시분할 시스템에서 유리<br><br>
* HRN(Highest Response ratio Next)
  * SJF의 약점<b>(긴 작업과 짧은 작업간의 불평등)</b>을 보완한 <b>비선점형</b> 기법
  * 우선순위 = (실항 + 대기) / 실행
  * 대기시간이 길수록, 실행시간이 짧을수록 우선순위 높아짐<br><br>
* 우선순위 스케쥴링
  * <b>우선순위</b>에 따라 CPU를 할당하는 <b>비선점 / 선점</b> 스케쥴링
  * 우선순위 같으면 FCFS
  * 시간 제한, 메모리 요구량, 열린 파일의 수, 프로세스의 중요성, 자원 사용 비용 에 따라 결정<br><br>
* RR(Round Robin)
  * <b>시간 할당량</b>(보통 10~100ms) 단위로 CPU를 할당하는 <b>선점</b> 스케쥴링
  * 시분할 시스템을 위해 셜계됨<br><br>
* MLQ(MultiLevel Queue)
  * 특징에 따라 그룹핑해서 <b>여러가지 스케쥴링이 같이 사용</b>되는 스케쥴링
  * 프로세스는 각 특성에 따라 한 개의 큐에 영구적으로 배당
  * 각 큐는 독자적인 스케쥴링 기법 사용
  * 큐와 큐 사이에는 선점 우선순위 스케쥴링의
  * 우선순위가 높은 큐가 비어있지 않으면 낮은 큐는 실행 불가<br><br>
* MFQ(Miltilevel Feedback Queue)
  * 라운드 로빈 사용
  * 큐와 큐 사이 이동 가능
  * 큐와 큐 사이에는 비선점 스케쥴링
  * 새로운 프로세스가 들어오면 높은 우선순위 할당 -&gt; 점차 낮은 우선순위 부여
  * 짧은 프로세스에 유리
  * 입출력 위주의 작업에 우선권 부여
  * 하위 큐로 갈수록 TS(Time Slice)가 점점 커진다.
  * 대기시간이 길어지면 우선순위를 높여주는 경우도 있음
