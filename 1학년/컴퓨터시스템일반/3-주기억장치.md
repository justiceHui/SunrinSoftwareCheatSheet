##### 주기억장치 관리?
* 기억장치의 효율성과 성능 향상을 위해 <b>어떤 프로세스를 어디에 적재할 지</b>를 정하는 것

##### 컴퓨터의 자료 구조 처리 단위
<ul>
  <li>bit : 정보 표현의 최소 단위(2진수)</li>
  <li>nibble : 4bit, 16개 정보 표현 가능</li>
  <li>byte : 8bit = 1byte</li>
  <li>word : cpu가 한번에 처리할 수 있는 명령의 단위(1word = 4btye)</li>
</ul>

##### 64bit 운영체제?
* 입출력 버스를 통해 한 번에 전송, 수신할 수 있는 데이터의 크기
* 2^64byte의 주소 범위 사용 가능

##### 단일 사용자(single user) 할당
<table>
  <tr><th>운영체제</th></tr>
  <tr><th>사용자 프로그램</th></tr>
  <tr><th>미 사용 영역</th></tr>
</table>

* 초기 시스템에서 실행될 프로그램 전체를 메모리의 연속 공간에 미리 적재하는 방법
* 한 번에 하나의 프로그램만 사용 가능
* 다중 프로그래밍 불가능
* 사용자 프로그램의 크기가 사용자 영역의 크기로 제한
* 논리메모리 < 물리메모리 의 경우에만 사용 가능
* 미 사용 영역에서 기억 장치 낭비

##### 고정 분할 다중 프로그래밍(정적 분할 프로그래밍)
<table>
  <tr><th>운영체제</th></tr>
  <tr><th>분할 1</th></tr>
  <tr><th>분할 2</th></tr>
  <tr><th>분할 3</th></tr>
  <tr><th>분할 4</th></tr>
</table>

* 메모리를 미리 몇 개의 고정된 개수와 크기로 분할하는 방법
* 개수와 크기는 운영체제를 생성할 때 설정되어 변경 불가
* 물리주소 = 분할기준 레지스터 + 논리주소
  * 논리주소가 분할영역 크기보다 크면 오류(트랩)
* 여러 프로세스들이 메모리에 상주하므로 메모리 보호 필요
* 분할기준 레지스터 : 가장 작은 합법적인 물리주소 저장
* 한계 레지스터 : 프로그램 영역이 저장되어 있는 범위의 크기 저장<br><br>
* 문제점
  * 분할된 내부 영역이 너무 작으면 대형 작업 기아 상태
  * 내부 단편화 : 남는 공간 생김
  * 외부 단편화 : 공간이 작고, 작업이 커서 못들어감

##### 적합 전략
* 최적 적합 전략
  * 가용 공간 중 적재 가능할 수 있는 가장 작은 공간에 할당
  * 가용 공간 절반만 탐색해도 공간 찾을 수 있음
  * 가용 공간 리스트가 정렬되어 있지 않으면 전체 리스트 탐색해야 함<br><br>
* 최악 적합 전략
  * 가용 공간 중 가장 큰 공간에 배치
  * 남은 공간이 커서 다른 프로그램 실행 가능
  * 큰 프로그램을 적재할 가용 공간이 없어짐<br><br>

##### 재배치 가능 동적 분할
<table>
  <tr><th>운영체제</th> <th rowspan="5">-&gt;</th><th>운영체제</th><th rowspan="5">-&gt;</th><th>운영체제</th></tr>
  <tr><th>다른 사용자</th><th>다른 사용자</th><th>다른 사용자</th></tr>
  <tr><th>4K 공백</th><th>4K 공백</th><th rowspan="2">12K 공백</th></tr>
  <tr><th>8K 사용자A</th><th>8K 공백됨</th></tr>
  <tr><th>다른 사용자</th><th>다른 사용자</th><th>다른 사용자</th></tr>
</table>

*  흩어져 있는 공백을 모아 하나의 커다란 연속 공간을 만들기 위해 재배치
* 통합
  * 공간을 모아서 큰 공간 생성 -&gt; 쓰레기 수집(Garbage Collection)
  * 이웃한 공간 병합 -&gt; 기억 장치 통합
* 압축
  * 현재 사용되고 있는 모든 공간을 주기억 장치의 한쪽 끝으로 이동


##### 페이징 기법
* 처리할 작업을 동일한 크기의 페이지로 나누어 처리
* 메모리 : 프레임이라는 고정 크기 블록으로 분할
* 프로세스 : 페이지라는 프레임과 동일한 크기의 고정된 영역으로 분할<br><br>
* 작업 수행 순서
  1. 프로그램에 소요되는 페이지를 결정하여 번호 부여
  2. 프로그램을 적재할 때 빈 프레임의 위치 파악
  3. 빈 프레임에 적재<br><br>
* 장단점
  * 빈 공간이 어떤 작업에도 사용 가능
  * 프레임간 외부 단편화 없음
  * 내부 단편화 발생<br><br>
* 페이지 맵 테이블(PMT, Page Map Table)
  * 페이지 번호 - 페이지 프레임 주소 대응
  * PMT는 레지스터로 구성 or 물리 메모리의 일부의 일부로 배정
  * 논리 페이지 : 테이블에서 해당 페이지의 프레임 번호 확인 후 실제 물리 메모리에 접근<br><br>
* 페이징 시스템의 물리적 주소 변환
```
PMT[페이지번호] = 프레임번호
func 논리주소2물리주소(페이지번호, 변위){
  return PMT[페이지번호] x 페이지사이즈 + 변위
}
```

* 페이징 하드웨어
  * CPU - 논리 주소, RAM - 물리 주소
  * 논리 주소(논리 주소 공간 크기 : 2^m, 페이지 크기 : 2^n)
<table>
  <tr> <th>페이지 번호</th> <th>변위</th> </tr>
  <tr> <th>p</th> <th>d</th> </tr>
  <tr> <td>m-n bit</td> <td>n bit</td> </tr>
</table>
* 세그먼트 메모리 기법
  * 세그먼트 : 연관된 기능을 수행하는 하나의 모듈 프로그램
  * 프로그램을 프로시저, 함수, 모듈 등의 각각 다른 크기를 갖는 세그먼트로 분리 후, 동적 분할 기법으로 메모리 할당
  * 외부 단편화 발생 : 사용 가능한 메모리의 모든 블록들이 작아 세그먼트 수용 불가
  * 할당 받을 때 까지 대기 or 압축하여 공간 생성<br><br>
* 세그먼트 테이블
  * 메모리 내 실제 주소의 시작과 끝을 저장
<table>
  <tr> <th>세그먼트 번호</th> <th>변위</th> <th>기준</th> <th>실제 물리 주소</th> </tr>
  <tr> <td>0</td> <td>1000</td> <td>1400</td> <td>1400 ~ 2400</td> </tr>
  <tr> <td>1</td> <td>400</td> <td>6300</td> <td>6300 ~ 6700</td> </tr>
  <tr> <td>2</td> <td>400</td> <td>4300</td> <td>4300 ~ 4700</td> </tr>
  <tr> <td>3</td> <td>1100</td> <td>3200</td> <td>3200 ~ 4300</td> </tr>
  <tr> <td>4</td> <td>1000</td> <td>4700</td> <td>4700 ~ 5700</td> </tr>
</table>
  * 세그먼트 2의 53번째 바이트 = 4300(기준) + 53 = 4353
  * 세그먼트 3의 852번째 바이트 = 3200 + 852 = 4052
  * 세그먼트 0의 1222번째 바이트 : 길이 초과 -&gt; 트랩 발생

##### 페이지화된 세그먼트 메모리 할당
* 페이징의 장단점
  * 메모리를 효율적으로 사용
  * 동일한 크기의 작업을 가지므로 많은 알고리즘 개발 가능
  * 내부 단편화 발생<br><br>
* 세그먼트의 장단점
  * 가변적인 데이터 구조와 모듈 처리
  * 외부 단편화 발생<br><br>
* 페이지화된 세그먼트 메모리 할당
  * 페이징과 세그멘테이션의 결합
  * 외부 단편화 현상 제거하면서 할당 과정 쉽게 해결

```
연습 문제 1.
페이지 크기 =  1k(= 1024 = 2^10) 일 때,
논리 주소 3085(10)의 페이지 번호, 변위?

정답 1.
페이지 번호 = 3085 / 1024
변위 = 3085 % 1024

연습 문제 2.
페이지 크기 = 4k(= 4096 = 2^12)
페이지 수 = 256개(= 2^8)
프레임 = 64개(= 2^6) 일 때,
논리 주소의 크기, 물리 주소의 크기?

정답 2.
  ※ log의 밑은 2
  -논리-
  페이지 번호(p) : 8 bit (log 페이지 수)
  변위(d) : 12 bit (log 페이지 크기)
  전체 : 20 bit (log 논리 주소 공간 크기 = log 페이지 수 + log 페이지 크기)

  -물리-
  페이지 번호(p) : 6 bit (log 프레임 개수)
  변위(d) : 12 bit (log 페이지 크기)
  전체 : 18 bit (log 물리 주소 공간 크기 = log 프레임 개수 + log 페이지 크기)
```
